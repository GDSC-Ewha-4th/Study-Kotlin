# Kotlin in Action Chap.4 QnA🔍

## #internal의 캡슐화 지원

자바는 package 단위로 접근자를 지정해주기 때문에 같은 package로 지정된 클래스면 외부 코드라고 해도 접근 가능하다. 예를 들어 한 package 안에 default와 public으로 지정된 클래스가 있다면, 외부 코드에서는 먼저 public 클래스를 선언한 후 그 클래스를 통해 default 클래스를 접근할 수 있다. 그러나 internal 접근자는 같은 모듈 안에서만 허용되므로, 외부 코드가 위와 같이 접근하는 것이 불가능하다. 따라서 캡슐화가 더 강하게 지켜진다. 

## #중첩 클래스와 내부 클래스

중첩 클래스는 바깥쪽 클래스에 대한 참조를 저장하지 않고, 내부 클래스는 바깥쪽 클래스에 대한 참조를 저장한다. 내부 클래스 사용은 지향하는 것이 좋은데, 이는 메모리 누수가 일어날 수 있기 때문이다.

Nested 클래스는 코드 상으로만 Outer 클래스에 속해있을 뿐, 실제로는(물리적으로는) 완전히 분리된 장소있기 때문에 Nested 클래스의 멤버 함수는 Outer 클래스의 프로퍼티나 멤버 함수에 접근할 수 없다. 자바의 static class 개념과 같다고 보면 된다. 그러나 inner 클래스는 바깥 클래스의 인스턴스로부터만 생성할 수 있으며, 바깥 클래스의 인스턴스를 가리키는 참조변수(this@Outer)를 내부적으로 가지고 있다.

## #주 생성자와 부 생성자

주 생성자는 주어진 인자를 통해 캡슐화하거나 초기화를 해주는 역할이고, 다른 부 생성자는 주 생성자를 호출하는 역할이다. 부 생성자만 선언되어 있으면 컴파일러가 주 생성자를 자동으로 만들어 준다. 자바에서는 인스턴스화할 때 매개변수의 타입과 갯수에 따라서 자동으로 일치하는 생성자를 호출해주지만, 코틀린에서는 주 생성자가 하나밖에 없기 때문에 클래스 본문에서 부 생성자로 만들어주어야 한다.

자바에서는 각각의 케이스(매개변수의 타입, 매개변수의 갯수)마다 전부 다 생성자가 있어야 한다. 그런데 코틀린에서는 디폴트 파라미터가 있기 때문에 이를 주 생성자로 만들고, 추가적으로 생성자가 필요할 경우 부 생성자로 선언해주면 된다. 지난 주차 내용 참고…

## #클래스의 위임(by)

데코레이터 패턴(Decorator pattern)이란 **주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴**으로, 기능 확장이 필요할 때 서브클래싱(상속) 대신 쓸 수 있는 유연한 대안이 될 수 있다. 

참고: 위임이란?

위임은 has a 관계로 클래스 내에서 위임 관계에 있는 클래스의 인스턴스를 가지고 있는 상태이다. 상속이 클래스 사이의 관계라면 위임은 인스턴스 사이의 관계라고 할 수 있다.

상속을 사용하기 위해서는 루트 코드에 가서 새로운 클래스를 만들어 주어야 하지만, 위임을 사용하면 런타임 시간에 객체를 생성하면서 유연하게 기능 추가가 가능하다. [관련 블로그](https://developer88.tistory.com/457?category=298822)

```kotlin
interface A { ... }
class B : A { }
val b = B()
// C를 생성하고, A에서 정의하는 B의 모든 메서드를 C에 위임한다.
class C : A by b
```

```kotlin
class Kia(private val premiumCar: Car) : Car{
	override val tire: String = premiumCar.tire
	override val body: String = premiumCar.body
	override fun manufacture() = premiumCar.manufacture()
} //클래스의 모든 내용이 다 상속받는 내용밖에 없기 때문에, 굳이 보일러플레이트 코드로 만들 필요가 없다.

class DelegatedKia(premiumCar: Car) : Car by premiumCar //한 줄로 간단하게 모두 위임할 수 있다.
```

## #동반 객체

참고: 싱글톤이란?

싱글톤은 **'하나'의 인스턴스만 생성하여 사용하는 디자인 패턴**이다. 인스턴스가 필요할 때, 똑같은 인스턴스를 만들지 않고 기존의 인스턴스를 활용하는 것을 뜻한다.

```kotlin
class A private constructor(val name: String) { //private 생성자
    companion object { //해당 페이지가 어떤 페이지인지에 대한 정보를 다른 페이지에 넘겨줄 때 필요함
        fun bar(): A {
            return A("zerog") //private 생성자를 호출할 수 있다
        }
    }
}

//사용
A.bar()
```

object 키워드로 싱글톤을 만들어 인스턴스를 만들면 다른 클래스에서 해당 인스턴스를 사용할 수 있다. 자바의 static과 비슷하지만 다른 점은 코틀린에서는 runtime에 만들어지고, 인스턴스가 만들어진다는 점이다.

new 키워드가 생성하는 인스턴스는 서브 클래스가 하고, 부모 클래스에서는 인스턴스 생성을 위한 인터페이스만을 제공한다. 객체를 만들어내는 패턴을 따로 두기 때문에 이를 팩토리 패턴이라고 한다. 즉, 생성자로 직접 객체를 생성하는 것이 아니라 메서드를 통해 객체를 생성하는 것이다.
