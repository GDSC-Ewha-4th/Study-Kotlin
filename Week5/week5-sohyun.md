1. 현재 영역에 있는 변수에 접근
   
   자바에서는
   
   1. 람다식에서 사용되는 외부 지역 변수는 **복사본이다**.
   2. 람다식에서 사용하는 변수가 **외부 지역변수**일 경우
   
   **final** 혹은 **effectively final** 인 경우에만 접근할 수 있다.
   
   - 지역 변수는 스택 영역에 생성됨. 따라서 지역 변수가 선언된 block이 끝나면 스택에서 제거됨. ⇒ 추후에 람다식이 수행될 때 참조할 수 없음.
   
   > 람다가 파이널 변수(val)을 포획하면 자바와 마찬가지로 그 변수의 값이 람다에 복사가 되어 저장된다. 하지만 람다가 변경 가능한 변수(var)를 포획하면 변수를 Ref 클래스 인스턴스에 넣습니다.
   
   파이널이 아닌 변수를 포획한 경우 ⇒ 변수를 특별한 Wrapper로 둘러싼다.
   
   Wrapper란 기본형 값들을 객체로 변환하여 작업을 수행할 때 사용한다
   
   참조를 final로 선언하면 참조는 변경 불가능하고, 그 객체 필드는 변경할 수 있다.
   
   참고한 링크: (https://devlog-wjdrbs96.tistory.com/392 )
- 핸들러 호출 순서:
  
  ### 비동기(Asynchronous)
  
  - 현재 작업의 응답이 끝나지 않은 상태에서 다음 작업이 요청된다.
  - 함수를 호출하는 곳에서 결과를 기다리지 않고, 다른 함수(callback)에서 결과를 기다린다.
  - 작업 완료 여부를 확인하지 않는다.
  
  이 함수는 항상 0을 반환한다. onClick 핸들러는 호출될 때마다 clicks의 값을 증가시키지만 그 값의 변경을 관찰할 수는 없다. 핸들러는 함수가 clicks를 반환한 다음에 호출되기 때문이다(?!)
1. 무명 클래스
   
   1. **무명 클래스**란 클래스 이름이 없는 클래스로 바디만 존재한다. 이는 클래스를 정의하는 동시에 객체를 생성하기 때문에 한 개의 객체만 만들 수 있다. new 이후 상속받고자하는 클래스나 인터페이스의 이름을 적어 사용한다. 무명 클래스에서는 변수와 메소드를 정의할 수 있는데 이 때 변수는 final 변수만 가능하다.
   2. 확장을 사용하는 경우에 유지보수가 불가능한 경우

2. 멤버 참조
   
   1. 중복을 줄이기 위해 함수를 참조하고 그 참조한 함수를 값으로 바뀌어 넘겨 준다.
   - 바운드 멤버 참조: 객체의 접근 횟수를 줄여준다.

3. SAM 생성자
   
   1. 결국 단일 추상 메소드, 람다로 생성한 함수형 인터페이스 인스턴스를 변수에 저장하는 경우에도 SAM 생성자를 사용할 수 있다.
   2. 내부에 구현이 안된 것. 람다를 자바에 전달해주고 싶을 때 SAM 인터페이스를 쓰면 람다를 전달해주는 것 같은 효과를 낸다.
   3. 변환이 자동으로 이루어지기 때문에 람다를 넘길 수 있다.

4. 즉시 계산과 지연 계산의 차이가 무엇인지 잘 모르겠습니다.
- 시퀀스를 사용하면 임시 컬렉션을 사용하지 않고 연쇄적으로 하기 때문에 메모리 아끼는 것과 동일하다.

- 자바의 스트림과 동일하다! : 만약 자바8 버전을 이용하면 스트림을 이용하면 되고, 만약 자바8 이전 걸 사용하면 시퀀스를 사용하면 된다!
  
  - (스트림 설명 링크 ) https://velog.io/@cham/JAVA-%EC%8A%A4%ED%8A%B8%EB%A6%BCStream
