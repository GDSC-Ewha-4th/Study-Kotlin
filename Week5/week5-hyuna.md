### 람다가 포획한 변수
- 자바는 람다 밖의 변수 중 파이널 변수에만 접근이 가능하다.
- 코틀린은 파이널이 아닌 변수에도 접근할 수 있다.

자바는 파이널인 변수에만 접근이 가능해서 람다 밖 변수에 대해 변경이 불가능하고, 코틀린은 파이널이 아닌 변수에 접근할 수 있기에 람다 밖 변수의 변경이 가능하다.

![](https://velog.velcdn.com/images/akimcse/post/84a115af-8a34-44c3-b2e2-889c015a634f/image.png)출처: https://bbang-work-it-out.tistory.com/18

<br>

### 멤버 참조
이미 선언된 함수를 중복을 줄이기 위해 값으로 사용하고자 `멤버 참조 ::` 를 사용한다.

멤버 참조 중에서도 클래스 인스턴스를 함께 저장한 다음 그 인스턴스에 대한 멤버를 호출해주는 것을 `바운드 멤버 참조`라고 한다.

멤버 참조를 생성할 때 클래스 인스턴스를 함께 저장한다는 것은 **객체를 넘길 필요가 없어진다**는 말이다. 따라서 객체 접근 횟수가 줄어든다는 장점이 있다.
```kotlin
// Kotlin 1.0 멤버 참조
val p = Person("Dmistry", 34)
val personAgeFunction = Person::age
println(personAgeFunction(p))
// 결과: 34

// Kotlin 1.1 바운드 멤버 참조
val p = Person("Dmistry", 34)
val ageFunction = p::age // p에 엮인 멤버 참조
println(ageFunction())
// 결과: 34
```

<br>

### 무명 클래스
`무명 클래스`는 말 그대로 이름이 없는 클래스다. 이름이 없다는 건 **불릴 일이 없다는 것**이다. 즉, 프로그램에서 일시적으로 사용되고 바로 버려질 놈이라는 소리다.

무명 클래스가 쓰이는 경우는 아래와 같다.

1. 프로그램에서 일시적으로 사용되는 단발성 객체의 경우 (이벤트 처리, 스레드 등)
2. 확장성을 부여하는 것이 유지보수 측면에서 더 불리한 경우
<br>

### 함수형 인터페이스와 SAM 생성자
자바는 함수형이 아니기 때문에 람다와 같은 것들을 전달해야 하는 경우 **람다를 함수형 인터페이스의 인스턴스로 변환**하여 보내야 한다.

그리고 위 내용처럼 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있도록 컴파일러가 자동으로 생성한 함수를 `SAM 생성자`라고 한다.
