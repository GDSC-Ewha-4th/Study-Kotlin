# Kotlin in action 스터디 7주차


## (1) 동등성 연산자: equals 자바와 코틀린의 차이

자바에서는 원시 타입을 비교하기 위해 `==` 를 사용한다. 이 경우 `==`는 두 피연산자의 값이 같은지 비교하는데, 이를 동등성이라고 한다. 값이 동등하다는 것이다.

```java

int a = 1
int b = 2

System.out.println(a == b) // false
```
한편 참조 타입인 두 피연산자 사이에 `==`를 사용할 경우 주소값으로 비교를 하게 된다.

두 피연산자의 주소값이 같은 곳을 가리키고 있다면 true를 반환하는 것이다. String의 경우 원시 타입이 아닌 참조 타입이기 때문에, 겉으로 보이는 문자가 똑같아 보여도 주소값이 다를경우 false가 출력된다.

```
String a = "hi" // 주소값 : 1번지
String b = "hi" // 주소값 : 2번지

System.out.println(a==b) // false
```
따라서 자바에서는 두 객체(참조 타입)의 동등성을 알기 위해서 `equals`를 호출해야 한다.
```
String a = "hi" // 주소값 : 1번지
String b = "hi" // 주소값 : 2번지

System.out.println(a.equals(b)) // true
```


코틀린에서도 `==`연산자가 기본이다. 그러나 자바와는 동작 방식에 조금 차이가 있다. 원시 타입 두개를 비교할 때는 `==`연산자가 동일하게 동작하지만, 참조 타입을 비교할 때 다르게 동작한다.

`==`는 내부적으로 equals를 호출한다. 따라서 참조 타입인 두 개의 String을 `==`연산으로 비교하면 주소값이 아닌 값(동등성)비교를 한다.

```
val a: String = "hi"
val b: String = "hi"

println(a == b) // true
```

> ## 참조 타입과 원시 타입 
>원시 타입은 정수, 실수, 문자, 논리 리터럴 등 실제 데이터 값을 저장하는 타입이다. int a = 10; 와 같이 코드를 작성했다면 정수 값이 할당될 수 있는 a라는 이름의 메모리 공간이 JVM 스택 영역에 생성되고, 10이라는 값이 들어간다. 즉, 원시 타입은 메모리 공간의 실제 데이터 값이 저장되어 있다.
>
> 참조 타입은 기본 타입을 제외한 타입으로, 객체의 주소를 저장하는 타입이다. 문자열, 배열, 열거형 상수, 클래스, 인터페이스 등이 있다. Java에서 실제 객체는 JVM 힙 영역에 저장되며, 참조 타입 변수는 실제 객체의 주소를 JVM 스택 영역에 저장한다. 그리고 객체를 사용할 때마다 참조 변수에 저장된 객체의 주소를 불러와 사용하게 된다.
> 
> Person p = new Person(); 이라는 코드를 작성했다면 p라는 이름의 메모리 공간이 스택 영역에 생성되고, 생성된 p의 인스턴스는 힙 영역에 생성된다, 즉, 스택 영역에 생성된 참조 변수 p는 힙 영역에 생성된 p의 인스턴스 주소 값을 가지게 된다.

### 참조 타입의 주소 값을 비교(reference comparision)하고 싶다면?

코틀린은 자바에는 없는 ===연산자를 지원한다. 참조 비교를 위해서 === 연산자를 사용하면 된다. 즉, 자바의 주소 값 비교인 ==와 코틀린의 ===가 동일한 역할을 한다.

| expression | java  | kotlin  |
|:----------|:----------|:----------|
| ==  | 원시 타입은 값을 비교 / 참조 타입은 주소값 | 참조 타입은 equals로 자동 컴파일  |
|equals| 참조 타입의 값을 비교   | ==이 사용되기 때문에 거의 사용되지 않음   |
| ===    | 존재하지 않음 | 주소값 비교   |


## (2) 구조 분해 선언
```
class Point(val x: Int, val y: Int) {
    operator fun component1() = x
    operator fun component2() = y
}

```
=> 일반 클래스에서는 operator와 함께 오버로딩을 하여 사용한다.
> 참고 (데이터 클래스와 일반 클래스 정리)
>
> https://velog.io/@haero_kim/Kotlin-감동-실화-Data-Class-알아보기

데이터 클래스의 구조 분해 선언에서 코드는 아래와 같이 컴파일된다.

```
val(a, b) = data 
-> val a = data.component1()
   val b = data.component2()
```

여기서 데이터 클래스의 주 생성자에 들어있는 프로퍼티에 대해서는 컴파일러가 자동으로 componentN 함수를 만들어준다.

또한 경우에 따라서 모든 값이 필요하지 않다면 밑줄(_)로 대체할 수도 있다.

이러한 구조 분해 선언은 무한하게 componentN을 선언할 수는 없고 맨 앞에 다섯 개의 원소에 대해서만 componentN 함수를 제공한다.

이와 비슷한 기능으로는 코틀린 표준 라이브러리에 미리 정의된 `Pair`나 `Triple`클래스를 사용하면 함수에서 여러 값을 더 간단하게 반환할 수 있다.

또한 Map이나 List에 대해 이터레이션 할 때 굉장히 유용하다.
